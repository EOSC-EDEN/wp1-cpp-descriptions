# Checksum Generation and Recording

**Short Definition:** The TDA (Trustworthy Digital Archive) records checksums for every File.

## Description and Scope
A checksum or message digest is a fixed size stream of data generated by a transformation of the *File* data by means of an algorithm. Any change to the data would result in a change to the calculated digest. The algorithm can be a cyclic redundancy check or a cryptographic hash function.

The *File* checksums form an important part of the fixity information which is the cornerstone for performing bit-level digital preservation. The system must keep track of this message digest for each *File*. Due to the possibility of collisions (multiple data streams having the same checksum), storing multiple message digests generated by different algorithms is recommended. The TDA policy should define a list of required algorithms.

The Checksum Generation and Recording process is the action of acquiring and storing the message digests associated with any *File* that the system needs to keep track of. Files should come with any number of checksums generated prior to their submission. In that case, the system should store those checksums and use them as-is and new checksums should be generated for those algorithms that are missing.

## Authors
- Kris Dekeyser

## Contributors
- Johan Kylander
- Bertrand Caron

## Evaluators
- Felix Burger
- Maria Benauer
- Fen Zhang

## Process Definition

**Inputs:**
- File
- Storage management policy - Checksum algorithms

**Outputs:**
- Fixity metadata (one or multiple checksum(s) for the File as well as their associated algorithms)
- Provenance metadata (a timestamp or event that describes the checksum calculation)
- Storage management policy - Checksum algorithms

**Trigger Events:**
- A new *SIP* is submitted and processed (see `CPP-029`)
- *File* update or replacement due to Preservation Action (e.g. migration) (see `CPP-014`)
- Any other action that results in a new or updated *File* being added to the system

## Process Steps

| Step | Description                                                  | Inputs                                                         | Outputs                                                                      |
| :--- | :----------------------------------------------------------- | :------------------------------------------------------------- | :--------------------------------------------------------------------------- |
| 1    | <br>                    <br><br>Get the list of accepted checksum algorithms<br>                 | - <br>                        <br><br>Storage management policy - Checksum algorithms<br>                     | - <br>                        <br><br>List of accepted checksum algorithms<br>                     |
| 2    | <br>                    <br><br>Calculate the checksum for each algorithm<br>                 | - <br>                        <br><br>*File*<br>                    <br>- <br>                        <br><br>*List of checksum algorithms*<br>                     | - <br>                        <br><br>List of checksums for the *File* based on different algorithms<br>                     |
| 3    | <br>                    <br><br>Store the checksums in the *Fixity metadata* for the * File*<br>                 | - <br>                        <br><br>List of checksums for the *File* based on different algorithms<br>                     | - <br>                        <br><br>Updated *Fixity metadata* of the * File* in the TDA database<br>                     |
| 4    | <br>                    <br><br>Document the event and its datetime<br>                 | - <br>                        <br><br>*File*<br>                     | - <br>                        <br><br>Datetime for the checksum generation and other related *Provenance metadata*<br>                     |

## Rationale / Worst Case

| Purpose                                                | Worst Case                                                                                                                                              |
| :----------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------ |
| <br>                <br><br>Keeping track of the fixity information of each *File*<br>             | <br>                <br><br>Corrupted data can get undetected or be detected when it is too late to take corrective action<br>                          |
| <br>                <br><br>Event datetime for checksum generation<br>             | <br>                <br><br>No starting point from when the fixity can be checked (and guaranteed)<br>                                                  |
| <br>                <br><br>Multiple checksums for each *File*<br>             | <br>                <br><br>Collisions where changes to a *File* produce the same checksum, are more likely with a single checksum algorithm than with multiple checksum algorithms<br>             |

## Relationships

| Type        | Related CPP | Description                                                                                                                                                                                                                                           |
| :---------- | :---------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Required by | CPP-002     | <br>                <br><br>CPP-002 relies on fixity information as produced and stored by CPP-001, when triggered by CPP-025 Enabling Access and CPP-006 AIP Batch Export. When triggered by CPP-029 Ingest CPP-002 rather relies on the fixity information supplied in the SIP.<br>             |
| Required by | CPP-003     | <br>                <br><br>The integrity checking process relies on the fixity information as produced and stored by CPP-001.<br>                                                                                                                    |
| Required by | CPP-006     | <br>                <br><br>*Fixity metadata* is used to verify the integrity of data written into the exported AIP.<br>                                                                                                                              |
| Required by | CPP-016     | <br>                <br><br>The checksums and associated algorithms need to be stored in the * File*’s *Fixity metadata* is used to verify the integrity of data written into the exported AIP.<br>                                                   |

## Framework Mappings

- **CoreTrustSeal**
  - **Term:** 
                

Checksum (cf [Extended Guidance documentation](https://doi.org/10.5281/zenodo.7051096))
            
  - **Section:** 
                    
    
    Information Technology & Security/Storage & Integrity (R14)
                
- **Nestor Seal**
  - **Term:** 
                

Integrity
            
  - **Section:** 
                    
    
    C14 Integrity: Ingest Interface
                
- **ISO 16363**
  - **Term:** 
                

integrity measurements
            
  - **Section:** 
                    
    
    Checksum Generation: 3.3.5 The repository shall define, collect, track, and appropriately provide its information integrity measurements.
                    
    
    Recording: 4.1.6 The repository shall obtain sufficient control over the Digital Objects to preserve them.
                
- **OAIS**
  - **Section:** 
                    
    
    OAIS does not describe the process of checksum generation and recording in its functional model but defines fixity information as part of Administrative metadata, which is “necessary for adequate preservation of the Content Data Object”.
                
- **PREMIS**
  - **Term:** 
                

Message digest calculation
            
  - **Section:** 
                    
    
    The term “message digest calculation” is referenced in the glossary.
                    
    
    The general topic of fixity is addressed in section Fixity, Integrity, Authenticity, p. 258.
                

## Reference Implementations

### Public Documentation
- **TIB – Leibniz Information Centre for Science and Technology and University Library**
  - **Link:** 
                    //wiki.tib.eu/confluence/spaces/lza/pages/93608951/Metadata#Metadata-TMDTechnicalmetadata
- **CSC – IT Center for Science Ltd.**
  - **Link:** 
                    https://wiki.tib.eu/confluence/spaces/lza/pages/93608951/Metadata#Metadata-TMDTechnicalmetadata
  - **Comment:** section 2.4.4.2
- **Archivematica**
  - **Link:** 
                    https://www.archivematica.org/en/docs/archivematica-1.17/user-manual/transfer/transfer/#transfer-tab-microservices



---

# Checksum Validation

**Short Definition:** The TDA validates checksums against those stored in the Information Package at Ingest or Access.

## Description and Scope
The Checksum Validation process compares the checksums that come with the *Information Package*, with checksums based on the current state of the *File*'s data. Checksums of *Files* are validated at *Ingest* or *Access* to a TDA. The checksums may be either part of 1) a *SIP*; 2) an imported *AIP*; or 3) an *AIP* stored in the *TDA*.

A misalignment between the checksum algorithms used in the *Information Package* and the TDA's checksum policy's list of algorithms may occur. For example, incoming *Information Packages* (*SIPs* and *AIPs*) may include a checksum with a different algorithm created by the producer. In the case of * AIPs*, the checksum policy might have been updated during the lifecycle of the TDA, resulting in the removal and/or addition of algorithms. In such cases, the process should use whatever algorithm is associated with a given checksum to the best of its potential.

## Authors
- Kris Dekeyser

## Contributors
- Johan Kylander

## Evaluators
- Felix Burger
- Maria Benauer
- Laura Molloy

## Process Definition

**Inputs:**
- File

**Outputs:**
- Fixity metadata
- Provenance metadata (the checksum validation event, including the datetime)

**Trigger Events:**
- *SIP* or *AIP* import (see `CPP-029`)
- *DIP* generation (see `CPP-025`)
- *AIP* export (see `CPP-006`)

## Process Steps

| Step | Description                                                                                     | Inputs                               | Outputs                                                                                                                      |
| :--- | :---------------------------------------------------------------------------------------------- | :----------------------------------- | :--------------------------------------------------------------------------------------------------------------------------- |
| 1    | <br>                    <br><br>Get the list of pre-calculated checksums with their respective algorithms<br>                 | - <br>                        <br><br>Fixity information<br>                    <br>- <br>                        <br><br>Fixity information from *SIP*<br>                     | - <br>                        <br><br>List of checksums and algorithms<br>                                                   |
| 2    | <br>                    <br><br>Evaluate for each algorithm individually if it is supported by the system.<br>                 | - <br>                        <br><br>List of checksums and algorithms<br>                    <br>- <br>                        <br><br>Digital archive system configuration<br>                     | - <br>                        <br><br>Algorithm supported (step 3)<br>                    <br>- <br>                        <br><br>Algorithm not supported:<br>                        <br>                            <br>•  examine further procedure (e.g. based on legal agreements; submission policies; communication with producer, if possible)<br>                            <br>•  Process completed<br>                        <br>                     |
| 3    | <br>                    <br><br>For each algorithm, recalculate the checksum of the *File* and match it with the given checksum<br>                 | - <br>                        <br><br>*File*<br>                    <br>- <br>                        <br><br>List of checksums and algorithms<br>                     | - <br>                        <br><br>All *File* checksums match (step 5)<br>                    <br>- <br>                        <br><br>Alert that any of the *File* checksums does not match:<br>                        <br>                            <br>•  Examine further procedure<br>                            <br>•  Process completed<br>                        <br>                     |
| 5    | <br>                    <br><br>Document the event and its timestamp<br>                        | - <br>                        <br><br>All *File* checksums match<br>                     | - <br>                        <br><br>Datetime for the checksum generation in the Provenance metadata<br>                     |

## Rationale / Worst Case

| Purpose                                                            | Worst Case                                                                           |
| :----------------------------------------------------------------- | :----------------------------------------------------------------------------------- |
| <br>                <br><br>Making sure the data content is still in the condition as intended<br>             | <br>                <br><br>Data corruption during transfers into the system or during export could go unnoticed<br>             |

## Relationships

| Type                    | Related CPP | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| :---------------------- | :---------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Requires                | CPP-001     | <br>                <br><br>CPP-002 relies on fixity information as produced and stored by CPP-001, but only during CPP-025 Enabling Access and CPP-006 AIP Batch Export. During CPP-029 Ingest, the fixity information supplied by the SIP will be used instead.<br>                                                                                                                                                                                                                                                   |
| Required by             | CPP-006     | <br>                <br><br>To ensure the integrity of the data during transport from the TDA storage the exported Files' checksums need to be verified.<br>                                                                                                                                                                                                                                                                                                                                                            |
| Required by             | CPP-025     | <br>                <br><br>As the *DIP* is created, all *File* checksums need to be validated to ensure that the *DIP* is representative of the *AIP*.<br>                                                                                                                                                                                                                                                                                                                                                             |
| Required by             | CPP-029     | <br>                <br><br>For any *SIP* submitted to the TDA all included *File* checksums need to be checked to validate the integrity of the *Files*.<br>                                                                                                                                                                                                                                                                                                                                                           |
| Affinity with           | CPP-004     | <br>                <br><br>All new *AIP* copies must have their checksum validated to verify that the process was successful. However, the checksum validation is more mechanical in its nature, only aiming at verification of the copy process. The CPP-002 checksum validation is more comprehensive (including negotiations with producers and validation of results).<br>                                                                                                                                         |
| Affinity with           | CPP-030     | <br>                <br><br>All new *AIP* copies must have their checksum validated to verify that the process was successful. However, the checksum validation is more mechanical in its nature, only aiming at verification of the copy process. The CPP-002 checksum validation is more comprehensive (including negotiations with producers and validation of results).<br>                                                                                                                                         |
| Affinity with           | CPP-011     | <br>                <br><br>When *Files* are replicated, successful replication is validated by comparing the replicated *Files'* checksums against the original * Files'* checksums<br>                                                                                                                                                                                                                                                                                                                                |
| Not to be confused with | CPP-003     | <br>                <br><br>Both CPPs get input from CPP-001, and both calculate a checksum from an *Information package* and compare it to a given checksum. The difference is that CPP-002 is done during the *Ingest* or *Access* phases (relating to transfer of content, changes in space), while CPP-003 is done periodically during the preservation of the contents in the archival storage (relating to changes over time). Thus, CPP-002 and CPP-003 are not only triggered by different processes, but also trigger different responses.<br>             |

## Framework Mappings

- **CoreTrustSeal**
  - **Term:** 
                

Checksum (cf [Extended Guidance documentation](https://zenodo.org/records/7051096))
            
  - **Section:** 
                    
    
    Information Technology and Security/Storage & Integrity (R14)
                
- **OAIS**
  - **Term:** 
                

Quality assurance
            
  - **Section:** 
                    
    
    4.2.3.3 (Ingest)
                

## Reference Implementations

### Public Documentation
- **TIB - Leibniz Information Centre for Science and Technology and University Library**
  - **Link:** https://wiki.tib.eu/confluence/spaces/lza/pages/93608391/Preservation+of+data+integrity+as+part+of+the+process+routines
- **CSC - IT Center for Science Ltd.**
  - **Link:** https://urn.fi/urn:nbn:fi-fe2024051731943
  - **Comment:** Annex 3, section 2.1.1
- **Archivematica**
  - **Link:** https://www.archivematica.org/en/docs/archivematica-1.17/user-manual/transfer/transfer/#create-a-transfer-with-existing-checksums



---

# Integrity Checking

**Short Definition:** The TDA supports periodic integrity checking, reporting any damaged or missing Files.

## Description and Scope
Integrity checking is a periodically performed process where a checksum is calculated for a target *Information Package* and compared to the existing stored checksum (as calculated in CPP-001 Checksum Generation and Recording). The goal of integrity checking is to confirm that a target *Information Package* has remained unaltered across its life cycle. A *TDA* must perform and document periodic checks, and the frequency of the checks should be defined in its policy as part of the Risk Mitigation (CPP-012) approach.

Integrity checking is closely related to the process of Checksum Validation (CPP-002). Whereas Checksum Validation is tied to *Ingest* (CPP-029), Enabling *Access* (CPP-025), or Replication (CPP-011) (i.e. processes where *Files* are transferred or new copies are created), Integrity Checking is related to continuous risk management. Integrity checking aims to mitigate bit rot and provides evidence for trustworthy preservation by maintaining a continuous audit trail verifying that a *File* has remained unchanged and authentic over time.

Periodic integrity checks are performed separately on all accessible copies of a target *Information Package* (for example, off-line copies in a dark archive are usually excluded from periodic integrity checks). Copies on different storage media might be subjected to different intervals of checks. The results of the integrity checks, including *Fixity Metadata*, should be documented as preservation actions.

If integrity checks discover problems in the integrity of the target *Information Packages*, this information must be clearly documented in a digital archive's system, so that the broken *Information Packages* can be restored from valid copies (see CPP-004 Data Corruption Management).

## Authors
- Johan Kylander

## Contributors
- Bertrand Caron

## Evaluators
- Maria Benauer
- Felix Burger
- Laura Molloy

## Process Definition

**Inputs:**
- Information Package
- Storage management policy - Integrity checking
- Storage management policy - Checksum algorithms

**Outputs:**
- Fixity metadata
- Storage management information
- Fixity metadata
- Provenance metadata
- Storage management policy - Integrity checking
- Storage management policy - Checksum algorithms

**Trigger Events:**
- Frequency of integrity checks defined in a digital archive's policy (see `CPP-012`)
- Suspicion of an error triggering an integrity check on an ad hoc basis

## Process Steps

| Step | Description                                                                                                                                                                            | Inputs                                         | Outputs                                                                                               |
| :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------- | :---------------------------------------------------------------------------------------------------- |
| 1    | <br>                    <br><br>Gather a batch of targets to check and their corresponding *Fixity metadata* (e.g. *Information Packages* whose last-checked timestamp is older than the specified checking frequency)<br>                 | - <br>                        <br><br>Storage management policy - Integrity checking<br>                     | - <br>                        <br><br>*AIPs*<br>                    <br>- <br>                        <br><br>*Fixity metadata*<br>                     |
| 2a   | <br>                    <br><br>For each *AIP* in the selected batch: Gather the *AIP*'s fixity metadata<br>                                                                           | - <br>                        <br><br>*Fixity metadata*<br>                     | - <br>                        <br><br>*Fixity metadata*<br>                                           |
| 2b   | <br>                    <br><br>Calculate the checksum of the *AIP* from the specified *File* path<br>                                                                                 | - <br>                        <br><br>*Fixity metadata* (algorithms)<br>                     | - <br>                        <br><br>*Fixity metadata*<br>                                           |
| 2c   | <br>                    <br><br>Compare the calculated checksum with the stored checksum<br>                                                                                           | - <br>                        <br><br>*Fixity metadata*<br>                     | - <br>                        <br><br>Checksums match: proceed to next step<br>                    <br>- <br>                        <br><br>Alert that any of the checksums does not match: mark broken *AIP* for repair and proceed to next step<br>                     |
| 2d   | <br>                    <br><br>Store the new integrity checking event to the *AIP*<br>                                                                                                |                                                | - <br>                        <br><br>Provenance metadata<br>                                         |
| 2e   | <br>                    <br><br>Update the timestamp of the integrity check<br>                                                                                                        |                                                | - <br>                        <br><br>*Fixity metadata* (timestamp)<br>                               |
| 3    | <br>                    <br><br>Document the event and its timestamp<br>                                                                                                               |                                                | - <br>                        <br><br>Provenance metadata<br>                                         |

## Rationale / Worst Case

| Purpose                                 | Worst Case                                                                                                                           |
| :-------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| <br>                <br><br>Periodic integrity checks on all copies<br>             | <br>                <br><br>Data can get corrupted and degenerate (i.e. the chain of custody is not safeguarded, and the authenticity of *IPs* may be destroyed)<br>             |

## Relationships

| Type                    | Related CPP | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| :---------------------- | :---------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Requires                | CPP-001     | <br>                <br><br>CPP-001 is responsible for creating checksums that are used in integrity checking.<br>                                                                                                                                                                                                                                                                                                                                                                                                          |
| Requires                | CPP-012     | <br>                <br><br>The frequency and target of periodic integrity checks (CPP-003) is defined by an institutional storage management policy as part of risk mitigation (CPP-012).<br>                                                                                                                                                                                                                                                                                                                              |
| Required by             | CPP-013     | <br>                <br><br>Periodic integrity checking provides reports on the integrity of data and reports corrupted *AIPs*.<br>                                                                                                                                                                                                                                                                                                                                                                                         |
| Required by             | CPP-016     | <br>                <br><br>The timestamp of the *AIPs*' checksums needs to be updated to keep track of the last successful check.<br>                                                                                                                                                                                                                                                                                                                                                                                      |
| Affinity with           | CPP-007     | <br>                <br><br>Both processes aim to ensure the "health" of files. However, Integrity Checking focuses on detecting technical corruption of *Files* (e.g. bit rot), whereas virus scanning looks to mitigate human-made risks ( e.g. malicious code).<br>                                                                                                                                                                                                                                                      |
| Not to be confused with | CPP-002     | <br>                <br><br>Both CPPs can get input from CPP-001, and both calculate a checksum from an *Information Package* and compare it to a given checksum. The difference is that CPP-002 is done during the *Ingest* or *Access* phases (relating to transfer of content, changes in space), while CPP-003 is done periodically during the preservation of the contents in the archival storage (relating to changes over time). Thus, CPP-002 and CPP-003 are not only triggered by different processes, but also trigger different responses.<br>             |

## Framework Mappings

- **CoreTrustSeal**
  - **Term:** 

Fixity checks
  - **Section:** 
                    
    
    R14 Storage & Integrity
                
- **Nestor Seal**
  - **Term:** 

Integrity checks
  - **Section:** 
                    
    
    C15 Integrity: Functions of the archival storage
                
- **ISO 16363**
  - **Term:** 

Fixity checks
  - **Section:** 
                    
    
    4.4.1.2
                
- **OAIS**
  - **Term:** 
                

Error checking
            
  - **Section:** 
                    
    
    4.2.3.4
                
- **PREMIS**
  - **Term:** 
                

Fixity check
            
  - **Section:** 
                    
    
    1.5.2, Glossary
                

## Reference Implementations

### Public Documentation
- **TIB - Leibniz Information Centre for Science and Technology and University Library**
  - **Link:** https://wiki.tib.eu/confluence/spaces/lza/pages/93608391/Preservation+of+data+integrity+as+part+of+the+process+routines
- **TIB - Leibniz Information Centre for Science and Technology and University Library**
  - **Link:** https://wiki.tib.eu/confluence/spaces/lza/pages/93608373/Archival+Storage#ArchivalStorage-Integrityassurance
- **CSC - IT Center for Science Ltd.**
  - **Link:** https://digitalpreservation.fi/en/services/quality_reports/2024
- **Archivematica**
  - **Link:** https://www.archivematica.org/en/docs/storage-service-0.23/fixity/#fixity-docs
- **AUSSDA - Austrian Social Science Data Archive**
  - **Link:** https://aussda.at/fileadmin/user_upload/p_aussda/Documents/kaczmirek_bischof_2024_preservation_fixity_checks_v1_0-1.pdf



---

# Identifier Management

**Short Definition:** Identifiers are assigned to Objects, Information packages and/or Metadata, and managed along to their life cycle.

## Description and Scope
Identifier management is the process of creating and updating identifiers and assigning them to Objects, Metadata or Information packages. Identifiers are essential components of digital preservation systems, serving as stable, long-term references to Digital Objects that can remain valid even when the Objects themselves are moved, renamed, or migrated to new systems.

Identifiers must be managed throughout the entire life cycle, taking into account any changes to their associated Objects, Metadata or Information packages. It is important to consider that not all types of identifiers are globally unique, some are unique only within their own identifier system.

A Persistent Identifier (PID) system can be used to generate unequivocal (this term is preferred over the “unique” adjective applied traditionally to identifiers. Indeed, it suggests that an identifier must reference one and only one thing, while “unique” might suggest that the thing must be referenced by only one identifier) identifiers to ensure that Objects can be precisely identified worldwide. PIDs are machine-readable strings of characters that conform to a defined scheme. Through providing and updating the reference link in the Metadata, these identifiers prevent the fundamental problem of "link rot" and ensure reliable access to preserved Digital Objects over time. However, this requires continuous maintenance of the identifiers to keep the Metadata up-to-date. Depending on the use case, it may be useful to assign multiple identifiers from different systems to an entity. To be able to provide user-facing PIDs, a TDA must manage local identifiers which provide the minimal baseline for providing persistent access and control to the data.

Common examples of PIDs are Digital Object Identifier (DOI), Uniform Resource Name (URN), handles and Archival Resource Key (ARK). One advantage of using PIDs is that their Metadata can be used to not only provide information about the Object itself, but also about its status, access conditions, and storage location. Even Objects which are not publicly accessible or have been disposed, can be identified and described by a PID. PIDs can also be moved from one organisation’s administration to another.

All types of identifiers can be assigned to multiple levels of entities, creating a hierarchical identification structure that reflects the complex nature of digital collections and their preservation requirements. Identifiers are usually assigned on the level of a) Objects, b) collections and aggregations, and c) Information Packages (AIPs and DIPs). In addition, identifiers can be assigned to Metadata entities, collections of other related entities, and even institutions or persons.

Identifiers and their Metadata should be updated according to the entity’s life cycle. In particular, when an entity may be deleted, merged, split or become partially unavailable, its identifier should be preserved. Moreover, its Provenance metadata should be updated in order to provide proper detail of information to the end users about its initial entity as well as the relationships to potential new entities that were created from the initial one. When using PIDs, some changes (e.g. the creation of identical parallel copies of the data that create new internal identifiers for each copy) can be documented in the PID version Metadata without creating a new PID.

Identifiers in a TDA are created at specific strategic points throughout the preservation life cycle, with timing and methods varying based on institutional policies and system architectures. Identifiers are typically assigned during Ingest as part of the packaging process, ensuring that every preserved Object has a persistent reference from the moment it enters the system. However, some institutions create identifiers earlier in the workflow (e.g. during acquisition planning or transfer preparation). This is especially useful when using PIDs, since it allows for early referencing and tracking of Objects before they undergo preservation processing. Identifiers can also be created after the initial preservation processing is complete, particularly when the final preserved format and structure have been determined. Identifiers can be also assigned to services or Objects which are not stored in the TDA but only generated on the fly based on user requests.

Identifiers may reveal the hierarchical relationships in the identifier string (e.g. by using qualifiers) or might hide them by creating a whole new string for components. This CPP does not choose between these approaches. Similarly, it does not make any assumptions on the organisation in charge of managing identifiers and whether identifiers are managed by the TDA directly. Since PID management is relatively resource-intensive and can also be performed outside the scope of digital long-term preservation, no assumptions are made here about the structure or organisation of this work area; instead, reference is made only to the entity “the PID management service”.

## Authors
- Mikko Laukkanen
- Juha Lehtonen

## Contributors
- Bertrand Caron
- Johan Kylander

## Evaluators
- Felix Burger
- Maria Benauer

## Process Definition

**Inputs:**
- Information package
- Object
- Identifier creation and management policy

**Outputs:**
- Technical metadata
- Descriptive metadata
- Identifier-enriched Information package, Object(s) or Metadata
- Provenance metadata
- Identifier creation and management policy

**Trigger Events:**
- Pre-ingest transfer preparation (see `CPP-029`)
- Ingestion workflow (see `CPP-029`)
- Creation of new Files or Representations (see `CPP-028`)
- Replacement of corrupted Files (see `CPP-004`)
- Data export (see `CPP-006`)
- Data replication (see `CPP-011`)
- Data migration (see `CPP-014`)
- Data normalisation (see `CPP-026`)
- Metadata ingest and creation (see `CPP-016`)
- Data version update (see `CPP-021`)
- Broken File needs a new identifier (see `CPP-027`)
- Information package, File or Metadata is removed from the TDA holdings (see `CPP-017`)

## Process Steps

| Step | Description                                                                                                             | Inputs                                                                                                 | Outputs                                         |
| :--- | :---------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------- | :---------------------------------------------- |
| 1a   | <br>                    <br><br>Reservation of identifier prior to new entity assignment (step 2)<br>                   | - <br>                        <br><br>A producer or a TDA has a need to reserve an identifier, (e.g. a PID, prior to the entity being added)<br>                     |                                                 |
| 1b   | <br>                    <br><br>New entity added or a need to assign an identifier to an existing entity (step 2)<br>                 | - <br>                        <br><br>*Object*<br>                    <br>- <br>                        <br><br>*Information package*<br>                    <br>- <br>                        <br><br>*Metadata*<br>                     |                                                 |
| 1c   | <br>                    <br><br>Entity with an identifier has changed (step 4)<br>                                      | - <br>                        <br><br>*Object*<br>                    <br>- <br>                        <br><br>*Information package*<br>                    <br>- <br>                        <br><br>*Metadata*<br>                     |                                                 |
| 1d   | <br>                    <br><br>Entity is disposed (step 7)<br>                                                         | - <br>                        <br><br>*Object*<br>                    <br>- <br>                        <br><br>*Information package*<br>                    <br>- <br>                        <br><br>*Metadata*<br>                     |                                                 |
| 2    | <br>                    <br><br>Create a new identifier according to the TDAs policy for identifier management<br>                 | - <br>                        <br><br>*Identifier creation and management policy*<br>                     | - <br>                        <br><br>Identifier<br>                     |
| 3    | <br>                    <br><br>Assign the new identifier to the entity and add it as a part of the entity’s Metadata<br>                 | - <br>                        <br><br>*(new) Identifier*<br>                    <br>- <br>                        <br><br>*Object*<br>                    <br>- <br>                        <br><br>*Information package*<br>                    <br>- <br>                        <br><br>*Metadata*<br>                     | - <br>                        <br><br>Metadata<br>                     |
| 4    | <br>                    <br><br>If the changed entity has a PID assigned to it: evaluate if a new PID is required<br>                 | - <br>                        <br><br>*Identifier creation and management policy*<br>                     | - <br>                        <br><br>Need for new PID identified (go back to step 2)<br>                    <br>- <br>                        <br><br>No need for new PID identified (step 5)<br>                     |
| 5    | <br>                    <br><br>Update or add identifier relationships (e.g. hierarchical relations, sequential relations etc.) for the assigned entity<br>                 |                                                                                                        | - <br>                        <br><br>Metadata<br>                     |
| 6    | <br>                    <br><br>Update Provenance metadata for the entity so that identifiers have a history<br>                 |                                                                                                        | - <br>                        <br><br>Provenance metadata<br>                     |
| 7    | <br>                    <br><br>If the entity is disposed: retain minimum metadata and the identifier for the disposed entity<br>                 | - <br>                        <br><br>*Disposed entity*<br>                                            |                                                 |

## Rationale / Worst Case

| Purpose                                                                                                                                                                       | Worst Case                                                                                                                                                    |
| :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| <br>                <br><br>The rationale for implementing PIDs in TDAs stems from fundamental challenges in maintaining long-term access to digital objects and the core mission of preservation itself.<br>             | <br>                <br><br>Link rot as well as problems and challenges in: Internal data management problemsm, System migrations, Format migrations, Activity tracking, Interoperability<br>             |

## Relationships

| Type               | Related CPP | Description                                                                                                                                                                  |
| :----------------- | :---------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Required by        | CPP-016     | <br>                <br><br>While ingesting into a TDA, the Metadata should be assigned an identifier. Also, the management functions of the Metadata may require replacing and/or updating identifiers.<br>             |
| Required by        | CPP-017     | <br>                <br><br>When the life cycle of the Digital Object or File ends, the identifier should be updated to “retired” status.<br>                                |
| Required by        | CPP-021     | <br>                <br><br>When an AIP gets a new version, the new AIP version must also be assigned a new identifier.<br>                                                  |
| Required by        | CPP-024     | <br>                <br><br>Enabling Discovery should make use of identifiers.<br>                                                                                           |
| Required by        | CPP-025     | <br>                <br><br>Accessing Digital Object, File(s) or Metadata should be based on identifiers as parameters.<br>                                                  |
| Required by        | CPP-029     | <br>                <br><br>The ingestion workflow is responsible for assigning identifiers to various entities in TDA, such as Files and Metadata.<br>                      |
| May be required by | CPP-004     | <br>                <br><br>If a File is corrupted, it may need to be repaired or replaced. During this process, a new identifier may be created.<br>                        |
| May be required by | CPP-011     | <br>                <br><br>When a Digital Object or File is replicated, the replicant may be assigned a new identifier.<br>                                                 |
| May be required by | CPP-013     | <br>                <br><br>The management and reporting should require that the data is identified with identifiers.<br>                                                    |
| May be required by | CPP-014     | <br>                <br><br>During format migration, the migrated File format may be assigned a new identifier.<br>                                                          |
| May be required by | CPP-019     | <br>                <br><br>The data quality assessment may include validating the identifiers and their linked resources.<br>                                               |
| May be required by | CPP-026     | <br>                <br><br>A normalised File format may be assigned with a new identifier.<br>                                                                              |
| May be required by | CPP-027     | <br>                <br><br>A repaired File may get a new identifier.<br>                                                                                                    |
| May be required by | CPP-028     | <br>                <br><br>A derivative of a File may get its own identifier.<br>                                                                                           |

## Framework Mappings

- **CoreTrustSeal**
  - **Term:** 
                

Persistent Identifiers
            
  - **Section:** 
                    
    
    R09 Preservation Plan
                    
    
    R12 Discovery and Identification
                
- **Nestor Seal**
  - **Term:** 
                

Persistent Identifiers
            
  - **Section:** 
                    
    
    C27 Identification
                
- **ISO 16363**
  - **Term:** 
                

Persistent Identifiers
            
  - **Section:** 
                    
    
    4.2.4
                    
    
    4.2.5.4
                    
    
    4.2.6.3
                
- **OAIS**
  - **Term:** 
                

Persistent Identifiers
            
  - **Section:** 
                    
    
    6.2.4
                
- **PREMIS**
  - **Term:** 
                

Persistent Identifiers
            
  - **Section:** 
                    
    
    Data dictionary, 1.1 objectIdentifier
                

## Reference Implementations

### Use Cases
- **DOI given for a research dataset by TDA**
  - **Institution:** CSC, Finland (Digital Preservation Service for Research Data)
  - **Documentation:** https://wiki.eduuni.fi/x/9ZRYH
  - **Problem:** 

Research dataset does not have a DOI
  - **Solution:**
```python
<html:p>Before submitting a dataset to TDA (DPS in Finland), the user describes the dataset 
                    via a description tool or via a metadata API. When a dataset has been submitted, TDA 
                    automatically creates a DataCite description including a new DOI, and eventually it 
                    creates a corresponding publicly available website for the dataset Metadata.</html:p>
```

### Public Documentation
- **TIB – Leibniz Information Centre for Science and Technology and University Library**
  - **Link:** 
                    https://wiki.tib.eu/confluence/spaces/lza/pages/93608951/Metadata#Metadata-Identifyingmetadata
- **CSC – IT Center for Science Ltd.**
  - **Link:** 
                    https://urn.fi/urn:nbn:fi-fe2020100578094
  - **Comment:** section 2.4.1.
- **Archivematica**
  - **Link:** 
                    https://www.archivematica.org/en/docs/archivematica-1.17/user-manual/transfer/transfer/#transfer-tab-microservices



---

# Virus Scanning

**Short Definition:** Information packages are virus checked, with appropriate facilities for quarantine.

## Description and Scope
Virus scanning is the process of examining *Files* as proposed for ingestion into an archive for the presence of malicious software (i.e. malware) such as viruses, trojans, worms, spyware, and ransomware etc. The primary goal of virus scanning is to detect and prevent such harmful code from entering the digital archive to safeguard the integrity and trustworthiness of the preserved content. This security measure protects not only the archival system itself, but also users or other connected systems that access or receive content from the archive. Effective virus scanning is a core step of the ingest process and an essential strategic component in **Risk Mitigation** (CPP-012), ensuring that the archive remains a secure and reliable repository for digital assets. It is a means to mitigate deliberate, human-made threats to digital preservation.

Virus scanning is first and foremost applied during ingest, acting as a checkpoint before *Files* are fully accepted and integrated into a TDA's holdings. In addition, it may be triggered during preservation (archival storage) or dissemination. This may be done either to ensure that no viruses have infected the content after ingest, or to make sure that disseminated content has been checked using up-to-date signature databases.

A TDA must employ virus scanning tools and malware signature databases to ensure effective and up-to-date threat detection. This includes a process to maintain and frequently update a malware signature database that is used by the virus scanning tools. The system must provide secure workspaces and guidelines for managing detected threats, which typically involves isolating suspicious *Files* in a staging or quarantine area to prevent potential harm to the storage. The TDA can reject and remove the contaminated *Files* or *Information packages* during ingest in cases where decontamination is not a viable option.

All scanning activities, detected threats, and subsequent actions (i.e. quarantine, rejection, deletion) must be documented as part of the ingest record and preservation actions as *Provenance metadata*. This documentation contributes to the audit trail of the ingested *Files* and should be incorporated into broader **Object Management Reporting** (CPP-013).

## Authors
- Mattias Levlin
- Johan Kylander

## Contributors
- Kris Dekeyser

## Evaluators
- Felix Burger
- Maria Benauer
- Fen Zhang

## Process Definition

**Inputs:**
- Information package(s)
- Malware signature database(s)
- Guidelines for managing detected threats
- Scan report

**Outputs:**
- Provenance metadata
- Malware signature database(s)
- Guidelines for managing detected threats
- Scan report

**Trigger Events:**
- Periodic quality check of *Files* (see `CPP-019`)
- Pre-access check of DIPs (see `CPP-025`)
- Ingest (see `CPP-029`)

## Process Steps

| Step | Description                                                                                                                     | Inputs                                              | Outputs                                                                                                                                                                                                                                                                                                                                                                    |
| :--- | :------------------------------------------------------------------------------------------------------------------------------ | :-------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | <br>                    <br><br>Receive and Stage Content: Content arrives and is placed in a temporary, isolated staging area designated for pre-ingest checks<br>                 | - <br>                        <br><br>*SIP(s)*<br>                     | - <br>                        <br><br>*SIP(s)* in the staging area<br>                                                                                                                                                                                                                                                                                                     |
| 2    | <br>                    <br><br>Select *AIP(s)* for virus scan and copy their *Files* to the staging area for checks<br>                 | - <br>                        <br><br>*AIP(s)*<br>                     | - <br>                        <br><br>*AIP(s)* in the staging area<br>                                                                                                                                                                                                                                                                                                     |
| 3    | <br>                    <br><br>Perform Scan: Initiate a comprehensive scan of all *Files* within the staged *Information packages*<br>                 | - <br>                        <br><br>*File(s)* in staging area<br>                    <br>- <br>                        <br><br>Configured virus scanners<br>                     | - <br>                        <br><br>Scan report/log (indicating clean *Files*, and any detected threats with file paths and malware names)<br>                                                                                                                                                                                                                           |
| 4    | <br>                    <br><br>Evaluate Scan Results<br>                                                                       | - <br>                        <br><br>Scan report/log<br>                     | - <br>                        <br><br>All *Files* reported as clean (step 7)<br>                    <br>- <br>                        <br><br>Any *Files* reported as infected or suspicious (step 5)<br>                                                                                                                                                                  |
| 5    | <br>                    <br><br>Handling infected or suspicious *Files*, the TDA conducts a first analysis<br>                  | - <br>                        <br><br>Infected/suspicious file(s)<br>                    <br>- <br>                        <br><br>Scan report<br>                    <br>- <br>                        <br><br>Guidelines for managing detected threats<br>                     | - <br>                        <br><br>Decontamination recommended: Move the identified *File(s)* to a secure quarantine area, isolated from other systems and content for further analysis and potential disinfection, and inform dedicated staff members (step 6)<br>                    <br>- <br>                        <br><br>Rejection recommended: Mark the *File(s)* (or the entire *SIP(s)* (as in case of ingest) for rejection. Notify the producer with reasons, if appropriate and/or defined by policy (end of the process)<br>                     |
| 6    | <br>                    <br><br>In-Depth Analysis: The personnel analyses the threat, leading to multiple potential outcomes<br>                 | - <br>                        <br><br>Quarantined file(s)<br>                    <br>- <br>                        <br><br>Notification to staff<br>                     | - <br>                        <br><br>False positive identified: the detected malware does not pose a threat. Whitelist the threat and move the *Files* from quarantine back to the staging (loop back to step 1)<br>                    <br>- <br>                        <br><br>Decontamination required and possible: The TDA disinfects the *Files* and moves the *Files* from quarantine back to the staging (loop back to step 1)<br>                    <br>- <br>                        <br><br>Decontamination required but not possible: Notify stakeholders: The TDA notifies the stakeholders that their content is at risk and that it most likely must be deleted and re-submitted. The *Files* are not moved away from the quarantine area. This is a more likely outcome for AIP *Files* that are scanned during the preservation (triggered by CPP-019). (step 7)<br>                     |
| 7    | <br>                    <br><br>Record the virus scan and its Outcome as a Preservation Event This documentation should include:<br>                    <br><br>                        <br>•  Datetime of scan<br>                        <br>•  Scanner software name<br>                        <br>•  Virus definition file version/date<br>                        <br>•  Files scanned<br>                        <br>•  Outcome for each file (e.g., 'clean', 'infected - [virus_name]', 'quarantined', 'rejected').<br>                        <br>•  Any additional actions taken<br>                    <br>                 | - <br>                        <br><br>Scan report<br>                    <br>- <br>                        <br><br>Actions taken (quarantine, disinfection, rejection)<br>                     | - <br>                        <br><br>*Provenance metadata*<br>                                                                                                                                                                                                                                                                                                            |
| 8    | <br>                    <br><br>Proceed with Clean Content or finalise Rejection:<br>                    <br><br>                        <br>•  If content is clean: release Files from the staging area or proceed with ingest<br>                        <br>•  If any relevant content was rejected: Finalise the rejection process and archive the documentation<br>                    <br>                 | - <br>                        <br><br>Clean *File(s)*<br>                    <br>- <br>                        <br><br>Documentation of scan event<br>                     | - <br>                        <br><br>Clean *File(s)* passed to the next ingest stage, or rejection process completed<br>                                                                                                                                                                                                                                                  |

## Rationale / Worst Case

| Purpose                                                                               | Worst Case                                                             |
| :------------------------------------------------------------------------------------ | :--------------------------------------------------------------------- |
| <br>                <br><br>Detection of malware in *SIP(s)*<br>                      | <br>                <br><br>Ingest of contaminated *Files*, risking destruction of the entire TDA.<br>             |
| <br>                <br><br>Process to handle and potentially reject and delete infected *SIP(s)*<br>             | <br>                <br><br>Ingest of contaminated *Files*, risking destruction of the entire TDA<br>             |
| <br>                <br><br>Processes to maintain up-to-date malware signature databases and virus scanning tools<br>             | <br>                <br><br>Ingest of contaminated *Files,* risking destruction of the entire TDA<br>             |
| <br>                <br><br>Detection of malware in AIP(s)<br>                        | <br>                <br><br>Risking destruction of the entire TDA.<br>             |

## Relationships

| Type                    | Related CPP | Description                                                                                                                                                                                                                                                                                                                         |
| :---------------------- | :---------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Requires                | CPP-012     | <br>                <br><br>Virus scanning is a direct risk mitigation activity against threats to content integrity and system security triggered by CPP-012.<br>                                                                                                                                                                  |
| Required by             | CPP-013     | <br>                <br><br>Reports on virus scanning activities, frequency of threats, and outcomes of the actions provide essential input for operational management and risk assessment.<br>                                                                                                                                     |
| Required by             | CPP-019     | <br>                <br><br>Virus scanning is performed as a step in the overall Data Quality Assessment process.<br>                                                                                                                                                                                                               |
| Required by             | CPP-029     | <br>                <br><br>Virus scanning is one of the core processes that must be performed during ingest.<br>                                                                                                                                                                                                                   |
| Affinity with           | CPP-003     | <br>                <br><br>Both processes aim to ensure the "health" of Files. However, Integrity Checking focuses on detecting technical corruption of Files (e.g. bit rot), whereas virus scanning looks to mitigate human-made risks ( e.g. malicious code).<br>                                                                |
| Not to be confused with | CPP-004     | <br>                <br><br>If a File is detected as infected and cannot be cleaned, it might be considered "damaged." However, CPP-004 typically applies to technical corruption or loss, rather than deliberately human-made damage such as malware-infected Files. In practice, infected Files are more likely to be replaced (by the producer) or rejected.<br>             |
| Not to be confused with | CPP-010     | <br>                <br><br>Both processes scan the Files to ensure that they are suitable for preservation. File Format Validation checks if a file conforms to its purported format specification (e.g. is this a valid PDF/A file?) while Virus Scanning checks for malware, regardless of format validity.<br>                  |

## Framework Mappings

- **CoreTrustSeal**
- **Nestor Seal**
- **ISO 16363**
- **OAIS**
  - **Term:** 
                

Quality Assurance (within Ingest), Security
            
  - **Section:** 
                    
    
    4.2.3.3
                    
    
    4.3.4
                
- **PREMIS**
  - **Term:** 
                

Event (with eventType 'virus check', Agent (the scanning software)
            
  - **Section:** 
                    
    
    Event Entity
                    
    
    Agent Entity
                    
    
    eventType Controlled vocabulary (2.2)
                

## Reference Implementations

### Use Cases
- **Virus Scan as Part of Ingest at CSC**
  - **Institution:** CSC – IT Center for Science Ltd., Finland
  - **Documentation:** https://www.clamav.net/
  - **Problem:** 
                    

Files must be scanned for viruses as part of the ingest pipeline to protect the TDA from viruses
                
  - **Solution:**
```python
<html:p>Python script to detect viruses using ClamAv virus 
                        scanner<html:br /><html:br />
                        def check_virus(path):<html:br />
                        """Scan files in directory with ClamAV virus scanner.<html:br />
                        ...
                    </html:p>
```

### Public Documentation
- **TIB – Leibniz Information Centre for Science and Technology and University Library**
  - **Link:** 
                    https://wiki.tib.eu/confluence/spaces/lza/pages/93608618/Ingest
- **CSC – IT Center for Science Ltd.**
  - **Link:** 
                    https://digitalpreservation.fi/en/services/quality_reports/2024
  - **Comment:** Monitoring of the Digital Preservation Services: "Up-to-date status of the virus check database"
- **Archivematica**
  - **Link:** 
                    https://www.archivematica.org/en/docs/archivematica-1.14/user-manual/transfer/scan-for-viruses/#scan-for-viruses
- **DANS (Data Archiving and Networked Services), Netherlands**
  - **Link:** 
                    https://www.coretrustseal.org/wp-content/uploads/2018/04/DANS-Electronic-Archiving-SYstem-EASY-.pdf
  - **Comment:** "Virus-scans are performed periodically for ingest by the web interface and standard for all other ingest ways (like SWORD)."



---

# Metadata Extraction

**Short Definition:** The TDA extracts characteristics (such as size, image dimensions, video codec, audio run time, creating application).

## Description and Scope
Metadata extraction is the process of analysing a File or a set of Files (i.e. a PREMIS Representation) by means of metadata extractor tools in order to retrieve its characteristics in an automated way. In the digital preservation community, this operation is sometimes referred to as “Characterisation”. Within EDEN, however, characterisation is used to identify all operations aiming to extract properties from digital Files (CPP-008 File Format Identification, CPP-009 Metadata Extraction, and CPP-010 File Format Validation).

Metadata Extraction is generally performed at a File level; in some cases it has to be applied to a complex file structure that is not wrapped in a container File. For example, moving images stored as a sequence of DPX Files are handled as a whole by the metadata extractor tool MediaInfo.

File properties as gathered through Metadata Extraction are generally considered “Technical metadata”. However, by parsing the File, the process also extracts a wide range of its internal Descriptive, Provenance and Rights metadata.

Knowledge of these characteristics is a key requirement for many subsequent operations. In particular, it is essential for CPPs producing new Representations (i.e. CPP-026 File Normalisation, CPP-027 File Repair, CPP-014 Format Migration, and CPP-028 Creation of Derivatives) as they require further Metadata beyond the file format information as provided by CPP-008. Audiovisual Files are the most obvious example: Most identification tools provide information about the only container format, while any of the operations mentioned above will need at least the video and audio stream format. This is equally true for all other data types: TIFF may contain image streams compressed by different algorithms, PDF 1.7 might be portfolios containing arbitrary Files, etc.

There are different types of extraction tools available: a) Generalist metadata extractor tools which are able to perform metadata extraction on a great variety of file formats of different content types (e.g. [Exiftool](https://exiftool.org/)), b) content-specific tools which cover most of the file formats for a specific content type (e.g. [MediaInfo](https://mediaarea.net/fr/MediaInfo) for AV Files), c) format-specific tools which are specialised on a particular format (e.g. [EPUBcheck](https://www.w3.org/publishing/epubcheck/) for EPUBs, [metaflac](https://xiph.org/flac/documentation_tools_metaflac.html) for FLAC Files, etc.). Metadata extraction therefore relies on a format identification and is performed differently depending on the file format. TDAs might decide to apply several metadata extractor tools if a single tool cannot extract all required properties.

Metadata extraction - like any parsing operation - can fail and result in diagnostic error messages. These errors require systematic analysis to inform troubleshooting. In particular, the following issues may be detected by Metadata extraction errors:

* Encrypted Files; * Truncated or broken Files * Files assigned incorrect file format information.

The output of the metadata extractor tools should be recorded in the Information Package, as Technical, Descriptive, Rights or Provenance Metadata. It may be recorded directly as-is, or mapped to a metadata standard according to the TDA policy on metadata recording.

## Authors
- Bertrand Caron

## Contributors
- Juha Lehtonen

## Evaluators
- Matthew Addis
- Maria Benauer
- Fen Zhang

## Process Definition

**Inputs:**
- File or, in some specific cases, Representation
- Policies and detection methods for significant properties, risk properties and quality properties
- Metadata recording Policy

**Outputs:**
- Technical Metadata (Format identifier)
- Technical Metadata
- Provenance metadata
- Descriptive Metadata
- Structural Metadata
- Rights Metadata
- Errors and Warnings
- Policies and detection methods for significant properties, risk properties and quality properties
- Metadata recording Policy

**Trigger Events:**
- Ingest (see `CPP-029`)
- Re-run of metadata extraction because of the release of a new metadata extractor tool or tool version
- Verify the output of processes creating new Files or Representations (see `CPP-014`)

## Process Steps

| Step | Description                                                                                                                                                                                                          | Inputs                                                                                                                        | Outputs                                                                                                                                              |
| :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | <br>                    <br><br>Select a suitable metadata extractor tool for the File(s), depending on its format identifier and on requirements from Significant Properties Definition, Data Quality Assessment and Risk Definition and Extraction<br>                 | - <br>                        <br><br>Format identifier<br>                    <br>- <br>                        <br><br>Significant properties policy and detection method<br>                    <br>- <br>                        <br><br>Risk properties policy and detection method<br>                    <br>- <br>                        <br><br>Quality properties policy and detection method<br>                     | - <br>                        <br><br>Metadata extractor tool<br>                        <br><br>If relevant: configure the tool settings - syntax (XML, JSON, CSV, etc.), format (e.g., EBUCore, PBCore, in case of an AV File) and verbosity level.<br>                     |
| 2    | <br>                    <br><br>Applying one or sometimes several metadata extractor tool(s).<br>                                                                                                                    | - <br>                        <br><br>*File*<br>                    <br>- <br>                        <br><br>[Metadata extractor tool](https://coptr.digipres.org/index.php/Metadata_Extraction) configured according to selected settings<br>                     | - <br>                        <br><br>Tool(s) output<br>                    <br>- <br>                        <br><br>Errors and warnings<br>                     |
| 3    | <br>                    <br><br>Analyse the errors and troubleshoot, e.g., by removing encryption<br>                                                                                                                | - <br>                        <br><br>Errors and warnings<br>                                                                 |                                                                                                                                                      |
| 4    | <br>                    <br><br>Map the extractor tool(s) output to metadata standard(s)<br>                    <br><br>The output of the extractor tool may be recorded as-is in the Information package, or may be mapped into a technical metadata standard (e.g., MIX for still images).<br>                 | - <br>                        <br><br>Tool(s) output<br>                    <br>- <br>                        <br><br>Policy on metadata recording<br>                     | - <br>                        <br><br>Tool output in standard format(s)<br>                                                                          |
| 5    | <br>                    <br><br>Recording the results in the Information Package (i.e. in practice, in the digital archive database and/or in the physical Information Package)<br>                                  | - <br>                        <br><br>Tool output in a standard format<br>                                                    | - <br>                        <br><br>Technical metadata, optionally other types of metadata, recorded in the Information Package<br>                     |
| 6    | <br>                    <br><br>Document the event and its datetime<br>                                                                                                                                              |                                                                                                                               | - <br>                        <br><br>Provenance metadata<br>                                                                                        |

## Rationale / Worst Case

| Purpose                                                                                                                                                                                                                                                                         | Worst Case                                                                                                                                        |
| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------ |
| <br>                <br><br>All preservation actions beyond bit-level preservation are based on a comprehensive understanding of the File’s characteristics.<br>                                                                                                                | <br>                <br><br>Files of poor quality may be unidentified.<br>                <br><br>Derivatives may be unadapted to the end users’ needs.<br>                <br><br>The result of a migration may be partial, as some parts of the source File may not have been identified, thus not been copied to the target File.<br>             |
| <br>                <br><br>Metadata extraction involves accessing the contents of the File. Hence it is an essential means to detect problematic Files (including errors like: corrupted, non-conformant to format specification, encrypted or password protected, wrong file format identification etc.).<br>             | <br>                <br><br>Problematic Files are not detected.<br>                                                                               |

## Relationships

| Type               | Related CPP | Description                                                                                                                                                                                                                                                                                                        |
| :----------------- | :---------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Required by        | CPP-002     | <br>                <br><br>CPP-002 relies on fixity information as produced and stored by CPP-001, when triggered by CPP-025 Enabling Access and CPP-006 AIP Batch Export. When triggered by CPP-029 Ingest CPP-002 rather relies on the fixity information supplied in the SIP.<br>                              |
| Required by        | CPP-008     | <br>                <br><br>The selection of an appropriate extractor tool depends on file format information.<br>                                                                                                                                                                                                 |
| Required by        | CPP-019     | <br>                <br><br>The selection of an appropriate extractor tool depends on requirements from the Data Quality Assessment CPP.<br>                                                                                                                                                                       |
| Required by        | CPP-022     | <br>                <br><br>The selection of an appropriate extractor tool depends on requirements from the Significant Properties Definition CPP.<br>                                                                                                                                                             |
| Required by        | CPP-023     | <br>                <br><br>The selection of an appropriate extractor tool depends on requirements from the Risk Definition and Extraction CPP.<br>                                                                                                                                                                |
| Required by        | CPP-012     | <br>                <br><br>Preservation actions (i.e. migration, emulation) in the storage depend on the identification of Files that share the same properties.<br>                                                                                                                                              |
| Required by        | CPP-014     | <br>                <br><br>File format identification is generally limited to an indication of the container format, while migration can apply to any property of the Files. Technical metadata extraction is required to both assess the compliance of files format to the Archive’s format policy and control the outcome of the migration.<br>             |
| Required by        | CPP-016     | <br>                <br><br>Any metadata that was extracted from the File needs to be stored, searchable and retrievable<br>                                                                                                                                                                                       |
| Required by        | CPP-019     | <br>                <br><br>Metadata extraction returns Metadata that are used to assess the File quality (e.g. for an audiovisual File quality assessment may rely on Metadata such as bit depth, sampling frequency, etc.).<br>                                                                                  |
| Required by        | CPP-023     | <br>                <br><br>Metadata extraction returns Metadata that are used to identify preservation threats (e.g. for a PDF, the presence of an open password).<br>                                                                                                                                            |
| Required by        | CPP-024     | <br>                <br><br>Some Metadata provided to the consumer must have been extracted from the Files.<br>                                                                                                                                                                                                    |
| Required by        | CPP-029     | <br>                <br><br>Metadata extraction is one of the core processes that must be performed as part of Ingest.<br>                                                                                                                                                                                         |
| May be required by | CPP-010     | <br>                <br><br>Depending on the precision of the format registry used in the format identification process, the resulting information may be insufficient for selecting the right validation tool.<br>                <br><br>In such cases, additional Metadata from an extraction tool may be required. For example, if an organisation uses Unix File as its identification tool, which does not distinguish between different PDF “flavours”, and wants to validate PDF/A against the PDF/A standard.<br>                <br><br>In that case, metadata extraction will be necessary to identify the conformance level and select veraPDF as the suitable validation tool<br>             |
| May be required by | CPP-021     | <br>                <br><br>The documented event, datetime, and Provenance metadata from the metadata extraction may be required by AIP Versioning.<br>                                                                                                                                                            |
| May be required by | CPP-027     | <br>                <br><br>Tools extracting properties of the File or Representation are useful (and sometimes even necessary) for identifying erroneous format structures.<br>                                                                                                                                   |
| Affected by        | CPP-018     | <br>                <br><br>Either due to changing significant properties or due to updated tools, metadata extraction requirements can be affected.<br>                                                                                                                                                           |

## Framework Mappings

- **CoreTrustSeal**
  - **Term:** 
                

Quality control checks
            
  - **Section:** 
                    
    
    Section R10 (Quality assurance) implicitly requires metadata extraction as one of the processes implementing “quality control checks in place [that] ensure the completeness and understandability of data and metadata”.
                
- **Nestor Seal**
  - **Term:** 
                

Technical metadata collect[ion]
            
  - **Section:** 
                    
    
    C30 Technical metadata
                
- **ISO 16363**
  - **Section:** 
                    
    
    /
                
- **OAIS**
  - **Section:** 
                    
    
    /
                
- **PREMIS**
  - **Term:** 
                

Metadata extraction
            
  - **Section:** 
                    
    
    The PREMIS Data Dictionary mentions this operation as “characterization” ([p. 249, section Special Topics / Format information](https://www.loc.gov/standards/premis/v3/premis-3-0-final.pdf#page=259)), but the event type vocabulary maintained by the PREMIS Editorial Committee at [id.loc.gov](http://id.loc.gov) uses the term [“metadata extraction”](https://id.loc.gov/vocabulary/preservation/eventType/mee.html).
                

## Reference Implementations

### Use Cases
- **Metadata Extraction from AV material**
  - **Institution:** Bibliothèque nationale de France
  - **Problem:** 
                    

Discussion with AV experts required that several quality properties be extracted, in particular properties related to the [group of pictures](https://en.wikipedia.org/wiki/Group_of_pictures) .
                    

XML was the preferred syntax for the extractor tool output, as it could be easily wrapped in METS Files.
                
  - **Solution:**
```python
<html:p>BnF has selected the tool MediaInfo as its extractor tool for AV Files,
                        according to requirements collected by BnF. MPEG-7, one of its output
                        formats, being standardised and expressed in XML, was selected as the format
                        for Metadata to be stored in Archival Information Packages. As MediaInfo
                        provides natively MPEG-7 as one of its output formats, no mapping from the
                        tool output to a standard metadata format was required.</html:p>
```

### Public Documentation
- **TIB – Leibniz Information Centre for Science and Technology and University Library**
  - **Link:** https://wiki.tib.eu/confluence/spaces/lza/pages/93608618/Ingest
- **CSC – IT Center for Science Ltd.**
  - **Link:** https://urn.fi/urn:nbn:fi-fe2020100578096
  - **Comment:** section 5
- **Archivematica**
  - **Link:** 
                    https://www.archivematica.org/en/docs/archivematica-1.17/user-manual/preservation/preservation-planning/#characterization



---

# File Format Validation

**Short Definition:** The TDA validates Files against File format specifications.

## Description and Scope
File Format validation is the process of checking a *File*’s structure against the specifications of the format it purports to be, or it was identified as in File Format Identification (CPP-008). In addition to *file* structure, validation generally encompasses internal integrity checks to verify that the File is not truncated and that each of its components are intact (e.g. by using internal *Metadata* like CRC checksums of the frames, or size of the data streams).

Erroneous format structures have many different causes. Some examples are listed below:

* Improper behaviours of creation software (e.g. InDesign, in some previous versions, was known to export corrupted PDFs); * Partial or failed transfers (e.g. digital photographs transferred through an unstable Bluetooth connection); * Edition with a different software than the creation tool (e.g. PDFs produced with pdfTeX, then edited with Quark XPress).

The TDA validation policy should define the following aspects for each format:

* Tool(s) used to validate the *File*. Since validation tools may produce false positives and false negatives, combining multiple tools - if possible - is suggested depending on the complexity of the format - PDF, in particular, is a very complex format for which validation tools may return very different results. * Tool settings (e.g. strict or relaxed mode, verbosity, etc.); * Severity rating of the issue; * Guidelines for validation error handling.

The scope of format validation is limited to the conformance of the File against the structures as described in the format specification. It does not assess the quality of the information conveyed by the *File*. Thus, it is only one aspect of quality assurance, which can be automated or done manually. Although most of the File Format Validation process described in this CPP can be automated, human intervention is mandatory if the validity status of the File is “invalid”

Some tools (e.g. [JHOVE](https://jhove.openpreservation.org/) follow the XML validation logic and differentiate “well-formedness” (i.e. the *File* conforms to purely syntactic requirements) and “validity” (i.e. the *File* also complies with semantic requirements). In addition, tools may return additional information or warnings, e.g. if unrecognised or private chunks are found in the *File*. In such cases,the output of a validation process should include some additional free-text besides a short controlled term (e.g. “well-formed and valid”, “well-formed but not valid”, “not well-formed”)..

This CPP does not prescribe the action the TDA should undertake if File Format Validation returns errors, but rather includes fallback solutions, such as 1) ingesting the * File* as it is with warnings, 2) requesting a new delivery or searching for a suitable replacement, or 3) trying to repair the *File* (by triggering CPP-027 File Repair). One of these solutions should generally be preferred over rejecting the * Object*.

Format validation is a recommended process to detect potential risks caused by incorrect format structures. However, its application must be carefully evaluated based on organisational capacities and the digital Objects of investigation (see on this subject Paul Wheatley’s blog post “A valediction for validation?”, 11 October 2018, available at [https://www.dpconline.org/blog/a-valediction-for-validation](https://www.dpconline.org/blog/a-valediction-for-validation)). Depending on organisational capacities, and the control the TDA has over digital Objects (indeed, the TDA may be able to require new, valid Files from a digitisation contractor or a depositor subject to legal deposit; on the other hand, it may be impossible for a private donor to meet the requirements for valid Files), it may decide to not perform File Format Validation due to:

* The lack of suitable tool(s), in particular for proprietary formats; * The lack of skilled staff to handle errors returned by the process.

## Authors
- Bertrand Caron

## Contributors
- Kris Dekeyser

## Evaluators
- Matthew Addis
- Maria Benauer
- Laura Molloy

## Process Definition

**Inputs:**
- File
- File format specification
- File format policy - Validation

**Outputs:**
- Technical Metadata (File format identifier)
- Provenance metadata (Validity status)
- Technical Metadata
- Errors and Warnings
- File format specification
- File format policy - Validation

**Trigger Events:**
- Ingest (see `CPP-029`)
- Re-run of format validation because of the release of a new validation tool or tool version (Because validation tools may evolve, especially for complex formats, re-assessing the validity of files already in storage is advised.)
- Re-run of format identification and discrepancy between previous and current result (see `CPP-008`)

## Process Steps

| Step | Description                                                                                                                                                   | Inputs                                                                                                                                  | Outputs                                                                                                                                                                                      |
| :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | <br>                    <br><br>According to input, select the right tool(s) to perform format validation. If the provided Metadata is not sufficient, perform CPP-009 (Metadata extraction).<br>                 | - <br>                        <br><br>File format identifier<br>                    <br>- <br>                        <br><br>Technical metadata<br>                    <br>- <br>                        <br><br>File format policy - Validation<br>                     | - <br>                        <br><br>[Validation tool(s)](https://coptr.digipres.org/index.php/Validation)<br>                        <br><br>(Format validation is generally performed by a single tool. Nevertheless, for some complex formats like PDF, TDAs may want to use more than one tool to identify possible structure errors.)<br>                     |
| 2    | <br>                    <br><br>Apply the validation tools(s)<br>                                                                                             | - <br>                        <br><br>*File*<br>                    <br>- <br>                        <br><br>[Validation tool(s)](https://coptr.digipres.org/index.php/Validation); as a default, reference parsing tools associated with the format<br>                     | - <br>                        <br><br>Raw validation output<br>                    <br>- <br>                        <br><br>Errors and warnings<br>                                         |
| 3    | <br>                    <br><br>Check validity status<br>                                                                                                     | - <br>                        <br><br>Errors and warnings<br>                    <br>- <br>                        <br><br>Raw validation output<br>                     | - <br>                        <br><br>Confirm Validity status (step 4)<br>                    <br>- <br>                        <br><br>Invalid file detected (step 3a)<br>                     |
| 3a   | <br>                    <br><br>Conduct technical analysis (e.g. rendition and other uses of the File, comparison with the file format specification, etc.)<br>                 | - <br>                        <br><br>Errors and warnings<br>                    <br>- <br>                        <br><br>Validity status<br>                    <br>- <br>                        <br><br>File format specification<br>                     | - <br>                        <br><br>Results of manual tests<br>                                                                                                                            |
| 3b   | <br>                    <br><br>Assess and choose one among the following outputs (in the given order)<br>                                                    | - <br>                        <br><br>Results of manual tests<br>                                                                       | - <br>                        <br><br>Retain the File as it is<br>                    <br>- <br>                        <br><br>Find another valid Representation (e.g. by establishing contact with the producer)<br>                    <br>- <br>                        <br><br>Trigger File Repair to correct the file structure<br>                    <br>- <br>                        <br><br>Reject the *Object*<br>                     |
| 4    | <br>                    <br><br>Document the process<br>                                                                                                      |                                                                                                                                         | - <br>                        <br><br>Provenance metadata<br>                                                                                                                                |

## Rationale / Worst Case

| Purpose                                                                                                                                                                                                   | Worst Case       |
| :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------- |
| <br>                <br><br>Format validation may identify structural errors that would cause issues when attempting to render or transform the *File*. In particular, truncated * File* can be identified by File Format Validation.<br>             | <br>                <br><br>/<br>             |

## Relationships

| Type                    | Related CPP | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| :---------------------- | :---------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Requires                | CPP-008     | <br>                <br><br>File Format Validation requires a specialised tool. In general, the result of File Format Identification is enough to determine which tool should be used.<br>                                                                                                                                                                                                                                                                                                                                                                                                                     |
| May require             | CPP-009     | <br>                <br><br>Depending on the precision of the format registry used in the File Format Identification process, the resulting information may be insufficient for selecting the right validation tool. In such cases, additional Metadata from an extraction tool may be required. For example, if an organisation uses Unix File as its identification tool, which does not distinguish between different PDF “flavours”, and wants to validate PDF/A against the PDF/A standard. In that case, metadata extraction will be necessary to identify the conformance level and select veraPDF as the suitable validation tool.<br>             |
| Required by             | CPP-013     | <br>                <br><br>File Format Validation reports essential information on the well-formedness and validity of the Objects; validation errors; and data on the tools used in the process.<br>                                                                                                                                                                                                                                                                                                                                                                                                         |
| Required by             | CPP-014     | <br>                <br><br>File Format Validation should be undertaken after File Migration was performed to ensure that the target *File(s)* or *Representation(s)* are valid..<br>                                                                                                                                                                                                                                                                                                                                                                                                                          |
| Required by             | CPP-015     | <br>                <br><br>In order to have a decent level of confidence in the rendering process, the file format needs to be validated.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Required by             | CPP-023     | <br>                <br><br>Risks can be related to specific file format erroneous structures<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Required by             | CPP-027     | <br>                <br><br>File Repair is generally triggered by File Format Validation and is one of several ways to handle errors from this CPP.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| May be required by      | CPP-029     | <br>                <br><br>A TDA may validate the format of the submitted Files in the ingest phase.<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Not to be confused with | CPP-007     | <br>                <br><br>Both processes scan the Files to ensure that they are suitable for preservation. File Format Validation checks if a File conforms to its purported format specification (e.g. is this a valid PDF/A File?), while Virus Scanning checks for malware, regardless of format validity.<br>                                                                                                                                                                                                                                                                                            |
| Not to be confused with | CPP-008     | <br>                <br><br>File Format Identification is only about identifying the format while File Format Validation describes full scanning of the File to ensure it complies with the format standard.<br>                                                                                                                                                                                                                                                                                                                                                                                               |

## Framework Mappings

- **CoreTrustSeal**
  - **Section:** 
                    
    
    CTS does not explicitly mention format validation but it is in the scope of section Quality Assurance (R10) and understood as one of the “quality control checks in place to ensure the completeness and understandability of data”.
                
- **Nestor Seal**
  - **Section:** 
                    
    
    Format validation is not explicitly mentioned by Nestor Seal but is in scope of C21 “Submission Information Packages”; in particular, in the question “Which measures exist for validating the conformity of submission information packages?”.
                
- **ISO 16363**
  - **Term:** 

“checking that file formats are what they claim to be”
  - **Section:** 
                    
    
    Section 4.1.5: “The repository shall have an ingest process which verifies each SIP for completeness and correctness”
                
- **OAIS**
  - **Term:** 
                

“validation of SIP data”
            
  - **Section:** 
                    
    
    This operation is also in scope of what OAIS calls “validation of SIP data” in section 2.6.3 “Producer interaction”, where the standard suggests that the “validity” of SIPs are negotiated between the producer and the archive.
                
- **PREMIS**
  - **Term:** 
                

(Format) validation
            
  - **Section:** 
                    
    
    Section: "Non-core metadata", subsection: "Quirks and anomalies" (p. 262).
                    
    
    Section: "Fixity, integrity, authenticity", p. 258.
                

## Reference Implementations

### Use Cases
- **Format validation of born-digital sound**
  - **Institution:** Bibliothèque nationale de France
  - **Problem:** 
                    

BnF decided to validate *Files* to identify transfer issues. However, the substantial volume of data and the considerable processing time have presented significant challenges to the performance and scalability of the validation operation.
                
  - **Solution:**
```python
<html:p>FLAC <html:em>Files</html:em> are verified with the <html:a href="https://xiph.org/flac/documentation_tools_flac.html">flac command-line tool</html:a>, which ensures both the overall <html:em>File</html:em>'s internal integrity and that of every individual frame within the audio stream. This is achieved through calculation of the CRC32 checksum for each frame. As this process is labour-intensive, the choice was made to do it by sampling. </html:p>
                    <html:p>As the producer is generally a major label with trained professionals in the domain of audio data, the chosen error handling method is to request a new, hopefully valid <html:em>File</html:em>.</html:p>
```

### Public Documentation
- **TIB – Leibniz Information Centre for Science and Technology and University Library**
  - **Link:** https://wiki.tib.eu/confluence/spaces/lza/pages/93608618/Ingest
- **CSC – IT Center for Science Ltd.**
  - **Link:** https://urn.fi/urn:nbn:fi-fe2025040925236
  - **Comment:** section 5.2
- **Archivematica**
  - **Link:** https://www.archivematica.org/en/docs/archivematica-1.17/user-manual/preservation/preservation-planning/#characterization



---

